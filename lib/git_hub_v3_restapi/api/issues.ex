# NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
# https://openapi-generator.tech
# Do not edit the class manually.

defmodule ExOctocat.Api.Issues do
  @moduledoc """
  API calls for all endpoints tagged `Issues`.
  """

  alias ExOctocat.Connection
  import ExOctocat.RequestBuilder

  @doc """
  Add assignees to an issue
  Adds up to 10 assignees to an issue. Users already assigned to an issue are not replaced.

  ## Parameters

  - connection (ExOctocat.Connection): Connection to server
  - owner (String.t):
  - repo (String.t):
  - issue_number (integer()): issue_number parameter
  - opts (KeywordList): [optional] Optional parameters
    - :body (InlineObject103):
  ## Returns

  {:ok, ExOctocat.Model.IssueSimple.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec issues_add_assignees(Tesla.Env.client(), String.t(), String.t(), integer(), keyword()) ::
          {:ok, ExOctocat.Model.IssueSimple.t()} | {:error, Tesla.Env.t()}
  def issues_add_assignees(connection, owner, repo, issue_number, opts \\ []) do
    optional_params = %{
      :body => :body
    }

    %{}
    |> method(:post)
    |> url("/repos/#{owner}/#{repo}/issues/#{issue_number}/assignees")
    |> add_optional_params(optional_params, opts)
    |> ensure_body()
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {201, %ExOctocat.Model.IssueSimple{}}
    ])
  end

  @doc """
  Add labels to an issue

  ## Parameters

  - connection (ExOctocat.Connection): Connection to server
  - owner (String.t):
  - repo (String.t):
  - issue_number (integer()): issue_number parameter
  - opts (KeywordList): [optional] Optional parameters
    - :body (UNKNOWN_BASE_TYPE):
  ## Returns

  {:ok, [%Label{}, ...]} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec issues_add_labels(Tesla.Env.client(), String.t(), String.t(), integer(), keyword()) ::
          {:ok, list(ExOctocat.Model.Label.t())}
          | {:ok, ExOctocat.Model.ValidationError.t()}
          | {:ok, ExOctocat.Model.BasicError.t()}
          | {:error, Tesla.Env.t()}
  def issues_add_labels(connection, owner, repo, issue_number, opts \\ []) do
    optional_params = %{
      :body => :body
    }

    %{}
    |> method(:post)
    |> url("/repos/#{owner}/#{repo}/issues/#{issue_number}/labels")
    |> add_optional_params(optional_params, opts)
    |> ensure_body()
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {200, [%ExOctocat.Model.Label{}]},
      {410, %ExOctocat.Model.BasicError{}},
      {422, %ExOctocat.Model.ValidationError{}}
    ])
  end

  @doc """
  Check if a user can be assigned
  Checks if a user has permission to be assigned to an issue in this repository.  If the `assignee` can be assigned to issues in the repository, a `204` header with no content is returned.  Otherwise a `404` status code is returned.

  ## Parameters

  - connection (ExOctocat.Connection): Connection to server
  - owner (String.t):
  - repo (String.t):
  - assignee (String.t):
  - opts (KeywordList): [optional] Optional parameters
  ## Returns

  {:ok, nil} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec issues_check_user_can_be_assigned(
          Tesla.Env.client(),
          String.t(),
          String.t(),
          String.t(),
          keyword()
        ) :: {:ok, nil} | {:ok, ExOctocat.Model.BasicError.t()} | {:error, Tesla.Env.t()}
  def issues_check_user_can_be_assigned(connection, owner, repo, assignee, _opts \\ []) do
    %{}
    |> method(:get)
    |> url("/repos/#{owner}/#{repo}/assignees/#{assignee}")
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {204, false},
      {404, %ExOctocat.Model.BasicError{}}
    ])
  end

  @doc """
  Create an issue
  Any user with pull access to a repository can create an issue. If [issues are disabled in the repository](https://help.github.com/articles/disabling-issues/), the API returns a `410 Gone` status.  This endpoint triggers [notifications](https://docs.github.com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See \"[Secondary rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)\" and \"[Dealing with secondary rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)\" for details.

  ## Parameters

  - connection (ExOctocat.Connection): Connection to server
  - owner (String.t):
  - repo (String.t):
  - opts (KeywordList): [optional] Optional parameters
    - :body (InlineObject99):
  ## Returns

  {:ok, ExOctocat.Model.Issue.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec issues_create(Tesla.Env.client(), String.t(), String.t(), keyword()) ::
          {:ok, ExOctocat.Model.Issue.t()}
          | {:ok, ExOctocat.Model.ValidationError.t()}
          | {:ok, ExOctocat.Model.BasicError.t()}
          | {:ok, ExOctocat.Model.InlineResponse503.t()}
          | {:error, Tesla.Env.t()}
  def issues_create(connection, owner, repo, opts \\ []) do
    optional_params = %{
      :body => :body
    }

    %{}
    |> method(:post)
    |> url("/repos/#{owner}/#{repo}/issues")
    |> add_optional_params(optional_params, opts)
    |> ensure_body()
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {201, %ExOctocat.Model.Issue{}},
      {403, %ExOctocat.Model.BasicError{}},
      {422, %ExOctocat.Model.ValidationError{}},
      {503, %ExOctocat.Model.InlineResponse503{}},
      {404, %ExOctocat.Model.BasicError{}},
      {410, %ExOctocat.Model.BasicError{}}
    ])
  end

  @doc """
  Create an issue comment
  This endpoint triggers [notifications](https://docs.github.com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See \"[Secondary rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)\" and \"[Dealing with secondary rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)\" for details.

  ## Parameters

  - connection (ExOctocat.Connection): Connection to server
  - owner (String.t):
  - repo (String.t):
  - issue_number (integer()): issue_number parameter
  - opts (KeywordList): [optional] Optional parameters
    - :body (InlineObject105):
  ## Returns

  {:ok, ExOctocat.Model.IssueComment.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec issues_create_comment(Tesla.Env.client(), String.t(), String.t(), integer(), keyword()) ::
          {:ok, ExOctocat.Model.IssueComment.t()}
          | {:ok, ExOctocat.Model.ValidationError.t()}
          | {:ok, ExOctocat.Model.BasicError.t()}
          | {:error, Tesla.Env.t()}
  def issues_create_comment(connection, owner, repo, issue_number, opts \\ []) do
    optional_params = %{
      :body => :body
    }

    %{}
    |> method(:post)
    |> url("/repos/#{owner}/#{repo}/issues/#{issue_number}/comments")
    |> add_optional_params(optional_params, opts)
    |> ensure_body()
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {201, %ExOctocat.Model.IssueComment{}},
      {403, %ExOctocat.Model.BasicError{}},
      {410, %ExOctocat.Model.BasicError{}},
      {422, %ExOctocat.Model.ValidationError{}},
      {404, %ExOctocat.Model.BasicError{}}
    ])
  end

  @doc """
  Create a label

  ## Parameters

  - connection (ExOctocat.Connection): Connection to server
  - owner (String.t):
  - repo (String.t):
  - opts (KeywordList): [optional] Optional parameters
    - :body (InlineObject109):
  ## Returns

  {:ok, ExOctocat.Model.Label.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec issues_create_label(Tesla.Env.client(), String.t(), String.t(), keyword()) ::
          {:ok, ExOctocat.Model.Label.t()}
          | {:ok, ExOctocat.Model.ValidationError.t()}
          | {:ok, ExOctocat.Model.BasicError.t()}
          | {:error, Tesla.Env.t()}
  def issues_create_label(connection, owner, repo, opts \\ []) do
    optional_params = %{
      :body => :body
    }

    %{}
    |> method(:post)
    |> url("/repos/#{owner}/#{repo}/labels")
    |> add_optional_params(optional_params, opts)
    |> ensure_body()
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {201, %ExOctocat.Model.Label{}},
      {422, %ExOctocat.Model.ValidationError{}},
      {404, %ExOctocat.Model.BasicError{}}
    ])
  end

  @doc """
  Create a milestone

  ## Parameters

  - connection (ExOctocat.Connection): Connection to server
  - owner (String.t):
  - repo (String.t):
  - opts (KeywordList): [optional] Optional parameters
    - :body (InlineObject112):
  ## Returns

  {:ok, ExOctocat.Model.Milestone.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec issues_create_milestone(Tesla.Env.client(), String.t(), String.t(), keyword()) ::
          {:ok, ExOctocat.Model.ValidationError.t()}
          | {:ok, ExOctocat.Model.BasicError.t()}
          | {:ok, ExOctocat.Model.Milestone.t()}
          | {:error, Tesla.Env.t()}
  def issues_create_milestone(connection, owner, repo, opts \\ []) do
    optional_params = %{
      :body => :body
    }

    %{}
    |> method(:post)
    |> url("/repos/#{owner}/#{repo}/milestones")
    |> add_optional_params(optional_params, opts)
    |> ensure_body()
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {201, %ExOctocat.Model.Milestone{}},
      {404, %ExOctocat.Model.BasicError{}},
      {422, %ExOctocat.Model.ValidationError{}}
    ])
  end

  @doc """
  Delete an issue comment

  ## Parameters

  - connection (ExOctocat.Connection): Connection to server
  - owner (String.t):
  - repo (String.t):
  - comment_id (integer()): comment_id parameter
  - opts (KeywordList): [optional] Optional parameters
  ## Returns

  {:ok, nil} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec issues_delete_comment(Tesla.Env.client(), String.t(), String.t(), integer(), keyword()) ::
          {:ok, nil} | {:error, Tesla.Env.t()}
  def issues_delete_comment(connection, owner, repo, comment_id, _opts \\ []) do
    %{}
    |> method(:delete)
    |> url("/repos/#{owner}/#{repo}/issues/comments/#{comment_id}")
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {204, false}
    ])
  end

  @doc """
  Delete a label

  ## Parameters

  - connection (ExOctocat.Connection): Connection to server
  - owner (String.t):
  - repo (String.t):
  - name (String.t):
  - opts (KeywordList): [optional] Optional parameters
  ## Returns

  {:ok, nil} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec issues_delete_label(Tesla.Env.client(), String.t(), String.t(), String.t(), keyword()) ::
          {:ok, nil} | {:error, Tesla.Env.t()}
  def issues_delete_label(connection, owner, repo, name, _opts \\ []) do
    %{}
    |> method(:delete)
    |> url("/repos/#{owner}/#{repo}/labels/#{name}")
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {204, false}
    ])
  end

  @doc """
  Delete a milestone

  ## Parameters

  - connection (ExOctocat.Connection): Connection to server
  - owner (String.t):
  - repo (String.t):
  - milestone_number (integer()): milestone_number parameter
  - opts (KeywordList): [optional] Optional parameters
  ## Returns

  {:ok, nil} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec issues_delete_milestone(Tesla.Env.client(), String.t(), String.t(), integer(), keyword()) ::
          {:ok, nil} | {:ok, ExOctocat.Model.BasicError.t()} | {:error, Tesla.Env.t()}
  def issues_delete_milestone(connection, owner, repo, milestone_number, _opts \\ []) do
    %{}
    |> method(:delete)
    |> url("/repos/#{owner}/#{repo}/milestones/#{milestone_number}")
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {204, false},
      {404, %ExOctocat.Model.BasicError{}}
    ])
  end

  @doc """
  Get an issue
  The API returns a [`301 Moved Permanently` status](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-redirects-redirects) if the issue was [transferred](https://help.github.com/articles/transferring-an-issue-to-another-repository/) to another repository. If the issue was transferred to or deleted from a repository where the authenticated user lacks read access, the API returns a `404 Not Found` status. If the issue was deleted from a repository where the authenticated user has read access, the API returns a `410 Gone` status. To receive webhook events for transferred and deleted issues, subscribe to the [`issues`](https://docs.github.com/webhooks/event-payloads/#issues) webhook.  **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a pull request. For this reason, \"Issues\" endpoints may return both issues and pull requests in the response. You can identify pull requests by the `pull_request` key. Be aware that the `id` of a pull request returned from \"Issues\" endpoints will be an _issue id_. To find out the pull request id, use the \"[List pull requests](https://docs.github.com/rest/reference/pulls#list-pull-requests)\" endpoint.

  ## Parameters

  - connection (ExOctocat.Connection): Connection to server
  - owner (String.t):
  - repo (String.t):
  - issue_number (integer()): issue_number parameter
  - opts (KeywordList): [optional] Optional parameters
  ## Returns

  {:ok, ExOctocat.Model.Issue.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec issues_get(Tesla.Env.client(), String.t(), String.t(), integer(), keyword()) ::
          {:ok, nil}
          | {:ok, ExOctocat.Model.Issue.t()}
          | {:ok, ExOctocat.Model.BasicError.t()}
          | {:error, Tesla.Env.t()}
  def issues_get(connection, owner, repo, issue_number, _opts \\ []) do
    %{}
    |> method(:get)
    |> url("/repos/#{owner}/#{repo}/issues/#{issue_number}")
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {200, %ExOctocat.Model.Issue{}},
      {301, %ExOctocat.Model.BasicError{}},
      {404, %ExOctocat.Model.BasicError{}},
      {410, %ExOctocat.Model.BasicError{}},
      {304, false}
    ])
  end

  @doc """
  Get an issue comment

  ## Parameters

  - connection (ExOctocat.Connection): Connection to server
  - owner (String.t):
  - repo (String.t):
  - comment_id (integer()): comment_id parameter
  - opts (KeywordList): [optional] Optional parameters
  ## Returns

  {:ok, ExOctocat.Model.IssueComment.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec issues_get_comment(Tesla.Env.client(), String.t(), String.t(), integer(), keyword()) ::
          {:ok, ExOctocat.Model.IssueComment.t()}
          | {:ok, ExOctocat.Model.BasicError.t()}
          | {:error, Tesla.Env.t()}
  def issues_get_comment(connection, owner, repo, comment_id, _opts \\ []) do
    %{}
    |> method(:get)
    |> url("/repos/#{owner}/#{repo}/issues/comments/#{comment_id}")
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {200, %ExOctocat.Model.IssueComment{}},
      {404, %ExOctocat.Model.BasicError{}}
    ])
  end

  @doc """
  Get an issue event

  ## Parameters

  - connection (ExOctocat.Connection): Connection to server
  - owner (String.t):
  - repo (String.t):
  - event_id (integer()):
  - opts (KeywordList): [optional] Optional parameters
  ## Returns

  {:ok, ExOctocat.Model.IssueEvent.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec issues_get_event(Tesla.Env.client(), String.t(), String.t(), integer(), keyword()) ::
          {:ok, ExOctocat.Model.BasicError.t()}
          | {:ok, ExOctocat.Model.IssueEvent.t()}
          | {:error, Tesla.Env.t()}
  def issues_get_event(connection, owner, repo, event_id, _opts \\ []) do
    %{}
    |> method(:get)
    |> url("/repos/#{owner}/#{repo}/issues/events/#{event_id}")
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {200, %ExOctocat.Model.IssueEvent{}},
      {404, %ExOctocat.Model.BasicError{}},
      {410, %ExOctocat.Model.BasicError{}},
      {403, %ExOctocat.Model.BasicError{}}
    ])
  end

  @doc """
  Get a label

  ## Parameters

  - connection (ExOctocat.Connection): Connection to server
  - owner (String.t):
  - repo (String.t):
  - name (String.t):
  - opts (KeywordList): [optional] Optional parameters
  ## Returns

  {:ok, ExOctocat.Model.Label.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec issues_get_label(Tesla.Env.client(), String.t(), String.t(), String.t(), keyword()) ::
          {:ok, ExOctocat.Model.Label.t()}
          | {:ok, ExOctocat.Model.BasicError.t()}
          | {:error, Tesla.Env.t()}
  def issues_get_label(connection, owner, repo, name, _opts \\ []) do
    %{}
    |> method(:get)
    |> url("/repos/#{owner}/#{repo}/labels/#{name}")
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {200, %ExOctocat.Model.Label{}},
      {404, %ExOctocat.Model.BasicError{}}
    ])
  end

  @doc """
  Get a milestone

  ## Parameters

  - connection (ExOctocat.Connection): Connection to server
  - owner (String.t):
  - repo (String.t):
  - milestone_number (integer()): milestone_number parameter
  - opts (KeywordList): [optional] Optional parameters
  ## Returns

  {:ok, ExOctocat.Model.Milestone.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec issues_get_milestone(Tesla.Env.client(), String.t(), String.t(), integer(), keyword()) ::
          {:ok, ExOctocat.Model.BasicError.t()}
          | {:ok, ExOctocat.Model.Milestone.t()}
          | {:error, Tesla.Env.t()}
  def issues_get_milestone(connection, owner, repo, milestone_number, _opts \\ []) do
    %{}
    |> method(:get)
    |> url("/repos/#{owner}/#{repo}/milestones/#{milestone_number}")
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {200, %ExOctocat.Model.Milestone{}},
      {404, %ExOctocat.Model.BasicError{}}
    ])
  end

  @doc """
  List issues assigned to the authenticated user
  List issues assigned to the authenticated user across all visible repositories including owned repositories, member repositories, and organization repositories. You can use the `filter` query parameter to fetch issues that are not necessarily assigned to you.   **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a pull request. For this reason, \"Issues\" endpoints may return both issues and pull requests in the response. You can identify pull requests by the `pull_request` key. Be aware that the `id` of a pull request returned from \"Issues\" endpoints will be an _issue id_. To find out the pull request id, use the \"[List pull requests](https://docs.github.com/rest/reference/pulls#list-pull-requests)\" endpoint.

  ## Parameters

  - connection (ExOctocat.Connection): Connection to server
  - opts (KeywordList): [optional] Optional parameters
    - :filter (String.t): Indicates which sorts of issues to return. Can be one of:   \\* `assigned`: Issues assigned to you   \\* `created`: Issues created by you   \\* `mentioned`: Issues mentioning you   \\* `subscribed`: Issues you're subscribed to updates for   \\* `all` or `repos`: All issues the authenticated user can see, regardless of participation or creation
    - :state (String.t): Indicates the state of the issues to return. Can be either `open`, `closed`, or `all`.
    - :labels (String.t): A list of comma separated label names. Example: `bug,ui,@high`
    - :sort (String.t): What to sort results by. Can be either `created`, `updated`, `comments`.
    - :direction (String.t): One of `asc` (ascending) or `desc` (descending).
    - :since (DateTime.t): Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
    - :collab (boolean()):
    - :orgs (boolean()):
    - :owned (boolean()):
    - :pulls (boolean()):
    - :per_page (integer()): Results per page (max 100)
    - :page (integer()): Page number of the results to fetch.
  ## Returns

  {:ok, [%Issue{}, ...]} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec issues_list(Tesla.Env.client(), keyword()) ::
          {:ok, nil}
          | {:ok, list(ExOctocat.Model.Issue.t())}
          | {:ok, ExOctocat.Model.ValidationError.t()}
          | {:ok, ExOctocat.Model.BasicError.t()}
          | {:error, Tesla.Env.t()}
  def issues_list(connection, opts \\ []) do
    optional_params = %{
      :filter => :query,
      :state => :query,
      :labels => :query,
      :sort => :query,
      :direction => :query,
      :since => :query,
      :collab => :query,
      :orgs => :query,
      :owned => :query,
      :pulls => :query,
      :per_page => :query,
      :page => :query
    }

    %{}
    |> method(:get)
    |> url("/issues")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {200, [%ExOctocat.Model.Issue{}]},
      {422, %ExOctocat.Model.ValidationError{}},
      {304, false},
      {404, %ExOctocat.Model.BasicError{}}
    ])
  end

  @doc """
  List assignees
  Lists the [available assignees](https://help.github.com/articles/assigning-issues-and-pull-requests-to-other-github-users/) for issues in a repository.

  ## Parameters

  - connection (ExOctocat.Connection): Connection to server
  - owner (String.t):
  - repo (String.t):
  - opts (KeywordList): [optional] Optional parameters
    - :per_page (integer()): Results per page (max 100)
    - :page (integer()): Page number of the results to fetch.
  ## Returns

  {:ok, [%SimpleUser{}, ...]} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec issues_list_assignees(Tesla.Env.client(), String.t(), String.t(), keyword()) ::
          {:ok, ExOctocat.Model.BasicError.t()}
          | {:ok, list(ExOctocat.Model.SimpleUser.t())}
          | {:error, Tesla.Env.t()}
  def issues_list_assignees(connection, owner, repo, opts \\ []) do
    optional_params = %{
      :per_page => :query,
      :page => :query
    }

    %{}
    |> method(:get)
    |> url("/repos/#{owner}/#{repo}/assignees")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {200, [%ExOctocat.Model.SimpleUser{}]},
      {404, %ExOctocat.Model.BasicError{}}
    ])
  end

  @doc """
  List issue comments
  Issue Comments are ordered by ascending ID.

  ## Parameters

  - connection (ExOctocat.Connection): Connection to server
  - owner (String.t):
  - repo (String.t):
  - issue_number (integer()): issue_number parameter
  - opts (KeywordList): [optional] Optional parameters
    - :since (DateTime.t): Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
    - :per_page (integer()): Results per page (max 100)
    - :page (integer()): Page number of the results to fetch.
  ## Returns

  {:ok, [%IssueComment{}, ...]} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec issues_list_comments(Tesla.Env.client(), String.t(), String.t(), integer(), keyword()) ::
          {:ok, ExOctocat.Model.BasicError.t()}
          | {:ok, list(ExOctocat.Model.IssueComment.t())}
          | {:error, Tesla.Env.t()}
  def issues_list_comments(connection, owner, repo, issue_number, opts \\ []) do
    optional_params = %{
      :since => :query,
      :per_page => :query,
      :page => :query
    }

    %{}
    |> method(:get)
    |> url("/repos/#{owner}/#{repo}/issues/#{issue_number}/comments")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {200, [%ExOctocat.Model.IssueComment{}]},
      {404, %ExOctocat.Model.BasicError{}},
      {410, %ExOctocat.Model.BasicError{}}
    ])
  end

  @doc """
  List issue comments for a repository
  By default, Issue Comments are ordered by ascending ID.

  ## Parameters

  - connection (ExOctocat.Connection): Connection to server
  - owner (String.t):
  - repo (String.t):
  - opts (KeywordList): [optional] Optional parameters
    - :sort (String.t): One of `created` (when the repository was starred) or `updated` (when it was last pushed to).
    - :direction (String.t): Either `asc` or `desc`. Ignored without the `sort` parameter.
    - :since (DateTime.t): Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
    - :per_page (integer()): Results per page (max 100)
    - :page (integer()): Page number of the results to fetch.
  ## Returns

  {:ok, [%IssueComment{}, ...]} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec issues_list_comments_for_repo(Tesla.Env.client(), String.t(), String.t(), keyword()) ::
          {:ok, ExOctocat.Model.ValidationError.t()}
          | {:ok, ExOctocat.Model.BasicError.t()}
          | {:ok, list(ExOctocat.Model.IssueComment.t())}
          | {:error, Tesla.Env.t()}
  def issues_list_comments_for_repo(connection, owner, repo, opts \\ []) do
    optional_params = %{
      :sort => :query,
      :direction => :query,
      :since => :query,
      :per_page => :query,
      :page => :query
    }

    %{}
    |> method(:get)
    |> url("/repos/#{owner}/#{repo}/issues/comments")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {200, [%ExOctocat.Model.IssueComment{}]},
      {422, %ExOctocat.Model.ValidationError{}},
      {404, %ExOctocat.Model.BasicError{}}
    ])
  end

  @doc """
  List issue events

  ## Parameters

  - connection (ExOctocat.Connection): Connection to server
  - owner (String.t):
  - repo (String.t):
  - issue_number (integer()): issue_number parameter
  - opts (KeywordList): [optional] Optional parameters
    - :per_page (integer()): Results per page (max 100)
    - :page (integer()): Page number of the results to fetch.
  ## Returns

  {:ok, [%IssueEventForIssue{}, ...]} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec issues_list_events(Tesla.Env.client(), String.t(), String.t(), integer(), keyword()) ::
          {:ok, list(ExOctocat.Model.IssueEventForIssue.t())}
          | {:ok, ExOctocat.Model.BasicError.t()}
          | {:error, Tesla.Env.t()}
  def issues_list_events(connection, owner, repo, issue_number, opts \\ []) do
    optional_params = %{
      :per_page => :query,
      :page => :query
    }

    %{}
    |> method(:get)
    |> url("/repos/#{owner}/#{repo}/issues/#{issue_number}/events")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {200, [%ExOctocat.Model.IssueEventForIssue{}]},
      {410, %ExOctocat.Model.BasicError{}}
    ])
  end

  @doc """
  List issue events for a repository

  ## Parameters

  - connection (ExOctocat.Connection): Connection to server
  - owner (String.t):
  - repo (String.t):
  - opts (KeywordList): [optional] Optional parameters
    - :per_page (integer()): Results per page (max 100)
    - :page (integer()): Page number of the results to fetch.
  ## Returns

  {:ok, [%IssueEvent{}, ...]} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec issues_list_events_for_repo(Tesla.Env.client(), String.t(), String.t(), keyword()) ::
          {:ok, list(ExOctocat.Model.IssueEvent.t())}
          | {:ok, ExOctocat.Model.ValidationError.t()}
          | {:error, Tesla.Env.t()}
  def issues_list_events_for_repo(connection, owner, repo, opts \\ []) do
    optional_params = %{
      :per_page => :query,
      :page => :query
    }

    %{}
    |> method(:get)
    |> url("/repos/#{owner}/#{repo}/issues/events")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {200, [%ExOctocat.Model.IssueEvent{}]},
      {422, %ExOctocat.Model.ValidationError{}}
    ])
  end

  @doc """
  List timeline events for an issue

  ## Parameters

  - connection (ExOctocat.Connection): Connection to server
  - owner (String.t):
  - repo (String.t):
  - issue_number (integer()): issue_number parameter
  - opts (KeywordList): [optional] Optional parameters
    - :per_page (integer()): Results per page (max 100)
    - :page (integer()): Page number of the results to fetch.
  ## Returns

  {:ok, [%TimelineIssueEvents{}, ...]} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec issues_list_events_for_timeline(
          Tesla.Env.client(),
          String.t(),
          String.t(),
          integer(),
          keyword()
        ) ::
          {:ok, list(ExOctocat.Model.TimelineIssueEvents.t())}
          | {:ok, ExOctocat.Model.InlineResponse415.t()}
          | {:ok, ExOctocat.Model.BasicError.t()}
          | {:error, Tesla.Env.t()}
  def issues_list_events_for_timeline(connection, owner, repo, issue_number, opts \\ []) do
    optional_params = %{
      :per_page => :query,
      :page => :query
    }

    %{}
    |> method(:get)
    |> url("/repos/#{owner}/#{repo}/issues/#{issue_number}/timeline")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {200, [%ExOctocat.Model.TimelineIssueEvents{}]},
      {404, %ExOctocat.Model.BasicError{}},
      {410, %ExOctocat.Model.BasicError{}},
      {415, %ExOctocat.Model.InlineResponse415{}}
    ])
  end

  @doc """
  List user account issues assigned to the authenticated user
  List issues across owned and member repositories assigned to the authenticated user.  **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a pull request. For this reason, \"Issues\" endpoints may return both issues and pull requests in the response. You can identify pull requests by the `pull_request` key. Be aware that the `id` of a pull request returned from \"Issues\" endpoints will be an _issue id_. To find out the pull request id, use the \"[List pull requests](https://docs.github.com/rest/reference/pulls#list-pull-requests)\" endpoint.

  ## Parameters

  - connection (ExOctocat.Connection): Connection to server
  - opts (KeywordList): [optional] Optional parameters
    - :filter (String.t): Indicates which sorts of issues to return. Can be one of:   \\* `assigned`: Issues assigned to you   \\* `created`: Issues created by you   \\* `mentioned`: Issues mentioning you   \\* `subscribed`: Issues you're subscribed to updates for   \\* `all` or `repos`: All issues the authenticated user can see, regardless of participation or creation
    - :state (String.t): Indicates the state of the issues to return. Can be either `open`, `closed`, or `all`.
    - :labels (String.t): A list of comma separated label names. Example: `bug,ui,@high`
    - :sort (String.t): What to sort results by. Can be either `created`, `updated`, `comments`.
    - :direction (String.t): One of `asc` (ascending) or `desc` (descending).
    - :since (DateTime.t): Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
    - :per_page (integer()): Results per page (max 100)
    - :page (integer()): Page number of the results to fetch.
  ## Returns

  {:ok, [%Issue{}, ...]} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec issues_list_for_authenticated_user(Tesla.Env.client(), keyword()) ::
          {:ok, nil}
          | {:ok, list(ExOctocat.Model.Issue.t())}
          | {:ok, ExOctocat.Model.BasicError.t()}
          | {:error, Tesla.Env.t()}
  def issues_list_for_authenticated_user(connection, opts \\ []) do
    optional_params = %{
      :filter => :query,
      :state => :query,
      :labels => :query,
      :sort => :query,
      :direction => :query,
      :since => :query,
      :per_page => :query,
      :page => :query
    }

    %{}
    |> method(:get)
    |> url("/user/issues")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {200, [%ExOctocat.Model.Issue{}]},
      {404, %ExOctocat.Model.BasicError{}},
      {304, false}
    ])
  end

  @doc """
  List organization issues assigned to the authenticated user
  List issues in an organization assigned to the authenticated user.  **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a pull request. For this reason, \"Issues\" endpoints may return both issues and pull requests in the response. You can identify pull requests by the `pull_request` key. Be aware that the `id` of a pull request returned from \"Issues\" endpoints will be an _issue id_. To find out the pull request id, use the \"[List pull requests](https://docs.github.com/rest/reference/pulls#list-pull-requests)\" endpoint.

  ## Parameters

  - connection (ExOctocat.Connection): Connection to server
  - org (String.t):
  - opts (KeywordList): [optional] Optional parameters
    - :filter (String.t): Indicates which sorts of issues to return. Can be one of:   \\* `assigned`: Issues assigned to you   \\* `created`: Issues created by you   \\* `mentioned`: Issues mentioning you   \\* `subscribed`: Issues you're subscribed to updates for   \\* `all` or `repos`: All issues the authenticated user can see, regardless of participation or creation
    - :state (String.t): Indicates the state of the issues to return. Can be either `open`, `closed`, or `all`.
    - :labels (String.t): A list of comma separated label names. Example: `bug,ui,@high`
    - :sort (String.t): What to sort results by. Can be either `created`, `updated`, `comments`.
    - :direction (String.t): One of `asc` (ascending) or `desc` (descending).
    - :since (DateTime.t): Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
    - :per_page (integer()): Results per page (max 100)
    - :page (integer()): Page number of the results to fetch.
  ## Returns

  {:ok, [%Issue{}, ...]} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec issues_list_for_org(Tesla.Env.client(), String.t(), keyword()) ::
          {:ok, list(ExOctocat.Model.Issue.t())}
          | {:ok, ExOctocat.Model.BasicError.t()}
          | {:error, Tesla.Env.t()}
  def issues_list_for_org(connection, org, opts \\ []) do
    optional_params = %{
      :filter => :query,
      :state => :query,
      :labels => :query,
      :sort => :query,
      :direction => :query,
      :since => :query,
      :per_page => :query,
      :page => :query
    }

    %{}
    |> method(:get)
    |> url("/orgs/#{org}/issues")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {200, [%ExOctocat.Model.Issue{}]},
      {404, %ExOctocat.Model.BasicError{}}
    ])
  end

  @doc """
  List repository issues
  List issues in a repository.  **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a pull request. For this reason, \"Issues\" endpoints may return both issues and pull requests in the response. You can identify pull requests by the `pull_request` key. Be aware that the `id` of a pull request returned from \"Issues\" endpoints will be an _issue id_. To find out the pull request id, use the \"[List pull requests](https://docs.github.com/rest/reference/pulls#list-pull-requests)\" endpoint.

  ## Parameters

  - connection (ExOctocat.Connection): Connection to server
  - owner (String.t):
  - repo (String.t):
  - opts (KeywordList): [optional] Optional parameters
    - :milestone (String.t): If an `integer` is passed, it should refer to a milestone by its `number` field. If the string `*` is passed, issues with any milestone are accepted. If the string `none` is passed, issues without milestones are returned.
    - :state (String.t): Indicates the state of the issues to return. Can be either `open`, `closed`, or `all`.
    - :assignee (String.t): Can be the name of a user. Pass in `none` for issues with no assigned user, and `*` for issues assigned to any user.
    - :creator (String.t): The user that created the issue.
    - :mentioned (String.t): A user that's mentioned in the issue.
    - :labels (String.t): A list of comma separated label names. Example: `bug,ui,@high`
    - :sort (String.t): What to sort results by. Can be either `created`, `updated`, `comments`.
    - :direction (String.t): One of `asc` (ascending) or `desc` (descending).
    - :since (DateTime.t): Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
    - :per_page (integer()): Results per page (max 100)
    - :page (integer()): Page number of the results to fetch.
  ## Returns

  {:ok, [%IssueSimple{}, ...]} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec issues_list_for_repo(Tesla.Env.client(), String.t(), String.t(), keyword()) ::
          {:ok, list(ExOctocat.Model.IssueSimple.t())}
          | {:ok, ExOctocat.Model.ValidationError.t()}
          | {:ok, ExOctocat.Model.BasicError.t()}
          | {:error, Tesla.Env.t()}
  def issues_list_for_repo(connection, owner, repo, opts \\ []) do
    optional_params = %{
      :milestone => :query,
      :state => :query,
      :assignee => :query,
      :creator => :query,
      :mentioned => :query,
      :labels => :query,
      :sort => :query,
      :direction => :query,
      :since => :query,
      :per_page => :query,
      :page => :query
    }

    %{}
    |> method(:get)
    |> url("/repos/#{owner}/#{repo}/issues")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {200, [%ExOctocat.Model.IssueSimple{}]},
      {301, %ExOctocat.Model.BasicError{}},
      {422, %ExOctocat.Model.ValidationError{}},
      {404, %ExOctocat.Model.BasicError{}}
    ])
  end

  @doc """
  List labels for issues in a milestone

  ## Parameters

  - connection (ExOctocat.Connection): Connection to server
  - owner (String.t):
  - repo (String.t):
  - milestone_number (integer()): milestone_number parameter
  - opts (KeywordList): [optional] Optional parameters
    - :per_page (integer()): Results per page (max 100)
    - :page (integer()): Page number of the results to fetch.
  ## Returns

  {:ok, [%Label{}, ...]} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec issues_list_labels_for_milestone(
          Tesla.Env.client(),
          String.t(),
          String.t(),
          integer(),
          keyword()
        ) :: {:ok, list(ExOctocat.Model.Label.t())} | {:error, Tesla.Env.t()}
  def issues_list_labels_for_milestone(connection, owner, repo, milestone_number, opts \\ []) do
    optional_params = %{
      :per_page => :query,
      :page => :query
    }

    %{}
    |> method(:get)
    |> url("/repos/#{owner}/#{repo}/milestones/#{milestone_number}/labels")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {200, [%ExOctocat.Model.Label{}]}
    ])
  end

  @doc """
  List labels for a repository

  ## Parameters

  - connection (ExOctocat.Connection): Connection to server
  - owner (String.t):
  - repo (String.t):
  - opts (KeywordList): [optional] Optional parameters
    - :per_page (integer()): Results per page (max 100)
    - :page (integer()): Page number of the results to fetch.
  ## Returns

  {:ok, [%Label{}, ...]} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec issues_list_labels_for_repo(Tesla.Env.client(), String.t(), String.t(), keyword()) ::
          {:ok, list(ExOctocat.Model.Label.t())}
          | {:ok, ExOctocat.Model.BasicError.t()}
          | {:error, Tesla.Env.t()}
  def issues_list_labels_for_repo(connection, owner, repo, opts \\ []) do
    optional_params = %{
      :per_page => :query,
      :page => :query
    }

    %{}
    |> method(:get)
    |> url("/repos/#{owner}/#{repo}/labels")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {200, [%ExOctocat.Model.Label{}]},
      {404, %ExOctocat.Model.BasicError{}}
    ])
  end

  @doc """
  List labels for an issue

  ## Parameters

  - connection (ExOctocat.Connection): Connection to server
  - owner (String.t):
  - repo (String.t):
  - issue_number (integer()): issue_number parameter
  - opts (KeywordList): [optional] Optional parameters
    - :per_page (integer()): Results per page (max 100)
    - :page (integer()): Page number of the results to fetch.
  ## Returns

  {:ok, [%Label{}, ...]} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec issues_list_labels_on_issue(
          Tesla.Env.client(),
          String.t(),
          String.t(),
          integer(),
          keyword()
        ) ::
          {:ok, list(ExOctocat.Model.Label.t())}
          | {:ok, ExOctocat.Model.BasicError.t()}
          | {:error, Tesla.Env.t()}
  def issues_list_labels_on_issue(connection, owner, repo, issue_number, opts \\ []) do
    optional_params = %{
      :per_page => :query,
      :page => :query
    }

    %{}
    |> method(:get)
    |> url("/repos/#{owner}/#{repo}/issues/#{issue_number}/labels")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {200, [%ExOctocat.Model.Label{}]},
      {410, %ExOctocat.Model.BasicError{}}
    ])
  end

  @doc """
  List milestones

  ## Parameters

  - connection (ExOctocat.Connection): Connection to server
  - owner (String.t):
  - repo (String.t):
  - opts (KeywordList): [optional] Optional parameters
    - :state (String.t): The state of the milestone. Either `open`, `closed`, or `all`.
    - :sort (String.t): What to sort results by. Either `due_on` or `completeness`.
    - :direction (String.t): The direction of the sort. Either `asc` or `desc`.
    - :per_page (integer()): Results per page (max 100)
    - :page (integer()): Page number of the results to fetch.
  ## Returns

  {:ok, [%Milestone{}, ...]} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec issues_list_milestones(Tesla.Env.client(), String.t(), String.t(), keyword()) ::
          {:ok, ExOctocat.Model.BasicError.t()}
          | {:ok, list(ExOctocat.Model.Milestone.t())}
          | {:error, Tesla.Env.t()}
  def issues_list_milestones(connection, owner, repo, opts \\ []) do
    optional_params = %{
      :state => :query,
      :sort => :query,
      :direction => :query,
      :per_page => :query,
      :page => :query
    }

    %{}
    |> method(:get)
    |> url("/repos/#{owner}/#{repo}/milestones")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {200, [%ExOctocat.Model.Milestone{}]},
      {404, %ExOctocat.Model.BasicError{}}
    ])
  end

  @doc """
  Lock an issue
  Users with push access can lock an issue or pull request's conversation.  Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see \"[HTTP verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs).\"

  ## Parameters

  - connection (ExOctocat.Connection): Connection to server
  - owner (String.t):
  - repo (String.t):
  - issue_number (integer()): issue_number parameter
  - opts (KeywordList): [optional] Optional parameters
    - :body (InlineObject106):
  ## Returns

  {:ok, nil} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec issues_lock(Tesla.Env.client(), String.t(), String.t(), integer(), keyword()) ::
          {:ok, nil}
          | {:ok, ExOctocat.Model.ValidationError.t()}
          | {:ok, ExOctocat.Model.BasicError.t()}
          | {:error, Tesla.Env.t()}
  def issues_lock(connection, owner, repo, issue_number, opts \\ []) do
    optional_params = %{
      :body => :body
    }

    %{}
    |> method(:put)
    |> url("/repos/#{owner}/#{repo}/issues/#{issue_number}/lock")
    |> add_optional_params(optional_params, opts)
    |> ensure_body()
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {204, false},
      {403, %ExOctocat.Model.BasicError{}},
      {410, %ExOctocat.Model.BasicError{}},
      {404, %ExOctocat.Model.BasicError{}},
      {422, %ExOctocat.Model.ValidationError{}}
    ])
  end

  @doc """
  Remove all labels from an issue

  ## Parameters

  - connection (ExOctocat.Connection): Connection to server
  - owner (String.t):
  - repo (String.t):
  - issue_number (integer()): issue_number parameter
  - opts (KeywordList): [optional] Optional parameters
  ## Returns

  {:ok, nil} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec issues_remove_all_labels(Tesla.Env.client(), String.t(), String.t(), integer(), keyword()) ::
          {:ok, nil} | {:ok, ExOctocat.Model.BasicError.t()} | {:error, Tesla.Env.t()}
  def issues_remove_all_labels(connection, owner, repo, issue_number, _opts \\ []) do
    %{}
    |> method(:delete)
    |> url("/repos/#{owner}/#{repo}/issues/#{issue_number}/labels")
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {204, false},
      {410, %ExOctocat.Model.BasicError{}}
    ])
  end

  @doc """
  Remove assignees from an issue
  Removes one or more assignees from an issue.

  ## Parameters

  - connection (ExOctocat.Connection): Connection to server
  - owner (String.t):
  - repo (String.t):
  - issue_number (integer()): issue_number parameter
  - opts (KeywordList): [optional] Optional parameters
    - :body (InlineObject104):
  ## Returns

  {:ok, ExOctocat.Model.IssueSimple.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec issues_remove_assignees(Tesla.Env.client(), String.t(), String.t(), integer(), keyword()) ::
          {:ok, ExOctocat.Model.IssueSimple.t()} | {:error, Tesla.Env.t()}
  def issues_remove_assignees(connection, owner, repo, issue_number, opts \\ []) do
    optional_params = %{
      :body => :body
    }

    %{}
    |> method(:delete)
    |> url("/repos/#{owner}/#{repo}/issues/#{issue_number}/assignees")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {200, %ExOctocat.Model.IssueSimple{}}
    ])
  end

  @doc """
  Remove a label from an issue
  Removes the specified label from the issue, and returns the remaining labels on the issue. This endpoint returns a `404 Not Found` status if the label does not exist.

  ## Parameters

  - connection (ExOctocat.Connection): Connection to server
  - owner (String.t):
  - repo (String.t):
  - issue_number (integer()): issue_number parameter
  - name (String.t):
  - opts (KeywordList): [optional] Optional parameters
  ## Returns

  {:ok, [%Label{}, ...]} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec issues_remove_label(
          Tesla.Env.client(),
          String.t(),
          String.t(),
          integer(),
          String.t(),
          keyword()
        ) ::
          {:ok, list(ExOctocat.Model.Label.t())}
          | {:ok, ExOctocat.Model.BasicError.t()}
          | {:error, Tesla.Env.t()}
  def issues_remove_label(connection, owner, repo, issue_number, name, _opts \\ []) do
    %{}
    |> method(:delete)
    |> url("/repos/#{owner}/#{repo}/issues/#{issue_number}/labels/#{name}")
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {200, [%ExOctocat.Model.Label{}]},
      {404, %ExOctocat.Model.BasicError{}},
      {410, %ExOctocat.Model.BasicError{}}
    ])
  end

  @doc """
  Set labels for an issue
  Removes any previous labels and sets the new labels for an issue.

  ## Parameters

  - connection (ExOctocat.Connection): Connection to server
  - owner (String.t):
  - repo (String.t):
  - issue_number (integer()): issue_number parameter
  - opts (KeywordList): [optional] Optional parameters
    - :body (UNKNOWN_BASE_TYPE):
  ## Returns

  {:ok, [%Label{}, ...]} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec issues_set_labels(Tesla.Env.client(), String.t(), String.t(), integer(), keyword()) ::
          {:ok, list(ExOctocat.Model.Label.t())}
          | {:ok, ExOctocat.Model.ValidationError.t()}
          | {:ok, ExOctocat.Model.BasicError.t()}
          | {:error, Tesla.Env.t()}
  def issues_set_labels(connection, owner, repo, issue_number, opts \\ []) do
    optional_params = %{
      :body => :body
    }

    %{}
    |> method(:put)
    |> url("/repos/#{owner}/#{repo}/issues/#{issue_number}/labels")
    |> add_optional_params(optional_params, opts)
    |> ensure_body()
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {200, [%ExOctocat.Model.Label{}]},
      {410, %ExOctocat.Model.BasicError{}},
      {422, %ExOctocat.Model.ValidationError{}}
    ])
  end

  @doc """
  Unlock an issue
  Users with push access can unlock an issue's conversation.

  ## Parameters

  - connection (ExOctocat.Connection): Connection to server
  - owner (String.t):
  - repo (String.t):
  - issue_number (integer()): issue_number parameter
  - opts (KeywordList): [optional] Optional parameters
  ## Returns

  {:ok, nil} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec issues_unlock(Tesla.Env.client(), String.t(), String.t(), integer(), keyword()) ::
          {:ok, nil} | {:ok, ExOctocat.Model.BasicError.t()} | {:error, Tesla.Env.t()}
  def issues_unlock(connection, owner, repo, issue_number, _opts \\ []) do
    %{}
    |> method(:delete)
    |> url("/repos/#{owner}/#{repo}/issues/#{issue_number}/lock")
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {204, false},
      {403, %ExOctocat.Model.BasicError{}},
      {404, %ExOctocat.Model.BasicError{}}
    ])
  end

  @doc """
  Update an issue
  Issue owners and users with push access can edit an issue.

  ## Parameters

  - connection (ExOctocat.Connection): Connection to server
  - owner (String.t):
  - repo (String.t):
  - issue_number (integer()): issue_number parameter
  - opts (KeywordList): [optional] Optional parameters
    - :body (InlineObject102):
  ## Returns

  {:ok, ExOctocat.Model.Issue.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec issues_update(Tesla.Env.client(), String.t(), String.t(), integer(), keyword()) ::
          {:ok, ExOctocat.Model.Issue.t()}
          | {:ok, ExOctocat.Model.ValidationError.t()}
          | {:ok, ExOctocat.Model.InlineResponse503.t()}
          | {:ok, ExOctocat.Model.BasicError.t()}
          | {:error, Tesla.Env.t()}
  def issues_update(connection, owner, repo, issue_number, opts \\ []) do
    optional_params = %{
      :body => :body
    }

    %{}
    |> method(:patch)
    |> url("/repos/#{owner}/#{repo}/issues/#{issue_number}")
    |> add_optional_params(optional_params, opts)
    |> ensure_body()
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {200, %ExOctocat.Model.Issue{}},
      {422, %ExOctocat.Model.ValidationError{}},
      {503, %ExOctocat.Model.InlineResponse503{}},
      {403, %ExOctocat.Model.BasicError{}},
      {301, %ExOctocat.Model.BasicError{}},
      {404, %ExOctocat.Model.BasicError{}},
      {410, %ExOctocat.Model.BasicError{}}
    ])
  end

  @doc """
  Update an issue comment

  ## Parameters

  - connection (ExOctocat.Connection): Connection to server
  - owner (String.t):
  - repo (String.t):
  - comment_id (integer()): comment_id parameter
  - opts (KeywordList): [optional] Optional parameters
    - :body (InlineObject100):
  ## Returns

  {:ok, ExOctocat.Model.IssueComment.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec issues_update_comment(Tesla.Env.client(), String.t(), String.t(), integer(), keyword()) ::
          {:ok, ExOctocat.Model.IssueComment.t()}
          | {:ok, ExOctocat.Model.ValidationError.t()}
          | {:error, Tesla.Env.t()}
  def issues_update_comment(connection, owner, repo, comment_id, opts \\ []) do
    optional_params = %{
      :body => :body
    }

    %{}
    |> method(:patch)
    |> url("/repos/#{owner}/#{repo}/issues/comments/#{comment_id}")
    |> add_optional_params(optional_params, opts)
    |> ensure_body()
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {200, %ExOctocat.Model.IssueComment{}},
      {422, %ExOctocat.Model.ValidationError{}}
    ])
  end

  @doc """
  Update a label

  ## Parameters

  - connection (ExOctocat.Connection): Connection to server
  - owner (String.t):
  - repo (String.t):
  - name (String.t):
  - opts (KeywordList): [optional] Optional parameters
    - :body (InlineObject110):
  ## Returns

  {:ok, ExOctocat.Model.Label.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec issues_update_label(Tesla.Env.client(), String.t(), String.t(), String.t(), keyword()) ::
          {:ok, ExOctocat.Model.Label.t()} | {:error, Tesla.Env.t()}
  def issues_update_label(connection, owner, repo, name, opts \\ []) do
    optional_params = %{
      :body => :body
    }

    %{}
    |> method(:patch)
    |> url("/repos/#{owner}/#{repo}/labels/#{name}")
    |> add_optional_params(optional_params, opts)
    |> ensure_body()
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {200, %ExOctocat.Model.Label{}}
    ])
  end

  @doc """
  Update a milestone

  ## Parameters

  - connection (ExOctocat.Connection): Connection to server
  - owner (String.t):
  - repo (String.t):
  - milestone_number (integer()): milestone_number parameter
  - opts (KeywordList): [optional] Optional parameters
    - :body (InlineObject113):
  ## Returns

  {:ok, ExOctocat.Model.Milestone.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec issues_update_milestone(Tesla.Env.client(), String.t(), String.t(), integer(), keyword()) ::
          {:ok, ExOctocat.Model.Milestone.t()} | {:error, Tesla.Env.t()}
  def issues_update_milestone(connection, owner, repo, milestone_number, opts \\ []) do
    optional_params = %{
      :body => :body
    }

    %{}
    |> method(:patch)
    |> url("/repos/#{owner}/#{repo}/milestones/#{milestone_number}")
    |> add_optional_params(optional_params, opts)
    |> ensure_body()
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      {200, %ExOctocat.Model.Milestone{}}
    ])
  end
end
